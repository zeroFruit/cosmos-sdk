(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{712:function(e,a,t){"use strict";t.r(a);var l=t(1),i=Object(l.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"adr-3-dynamic-capability-store"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#adr-3-dynamic-capability-store"}},[e._v("#")]),e._v(" ADR 3: Dynamic Capability Store")]),e._v(" "),t("h2",{attrs:{id:"changelog"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#changelog"}},[e._v("#")]),e._v(" Changelog")]),e._v(" "),t("ul",[t("li",[e._v("12 December 2019: Initial version")])]),e._v(" "),t("h2",{attrs:{id:"context"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[e._v("#")]),e._v(" Context")]),e._v(" "),t("p",[e._v("Full implementation of the "),t("a",{attrs:{href:"https://github.com/cosmos/ics",target:"_blank",rel:"noopener noreferrer"}},[e._v("IBC specification"),t("OutboundLink")],1),e._v(" requires the ability to create and authenticate object-capability keys at runtime (i.e., during transaction execution),\nas described in "),t("a",{attrs:{href:"https://github.com/cosmos/ics/tree/master/spec/ics-005-port-allocation#technical-specification",target:"_blank",rel:"noopener noreferrer"}},[e._v("ICS 5"),t("OutboundLink")],1),e._v(". In the IBC specification, capability keys are created for each newly initialised\nport & channel, and are used to authenticate future usage of the port or channel. Since channels and potentially ports can be initialised during transaction execution, the state machine must be able to create\nobject-capability keys at this time.")]),e._v(" "),t("p",[e._v("At present, the Cosmos SDK does not have the ability to do this. Object-capability keys are currently pointers (memory addresses) of "),t("code",[e._v("StoreKey")]),e._v(" structs created at application initialisation in "),t("code",[e._v("app.go")]),e._v(" ("),t("a",{attrs:{href:"https://github.com/cosmos/gaia/blob/dcbddd9f04b3086c0ad07ee65de16e7adedc7da4/app/app.go#L132",target:"_blank",rel:"noopener noreferrer"}},[e._v("example"),t("OutboundLink")],1),e._v(")\nand passed to Keepers as fixed arguments ("),t("a",{attrs:{href:"https://github.com/cosmos/gaia/blob/dcbddd9f04b3086c0ad07ee65de16e7adedc7da4/app/app.go#L160",target:"_blank",rel:"noopener noreferrer"}},[e._v("example"),t("OutboundLink")],1),e._v("). Keepers cannot create or store capability keys during transaction execution — although they could call "),t("code",[e._v("NewKVStoreKey")]),e._v(" and take the memory address\nof the returned struct, storing this in the Merklised store would result in a consensus fault, since the memory address will be different on each machine (this is intentional — were this not the case, the keys would be predictable and couldn't serve as object capabilities).")]),e._v(" "),t("p",[e._v("Keepers need a way to keep a private map of store keys which can be altered during transacton execution, along with a suitable mechanism for regenerating the unique memory addresses (capability keys) in this map whenever the application is started or restarted.\nThis ADR proposes such an interface & mechanism.")]),e._v(" "),t("h2",{attrs:{id:"decision"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#decision"}},[e._v("#")]),e._v(" Decision")]),e._v(" "),t("p",[e._v("The SDK will include a new "),t("code",[e._v("CapabilityKeeper")]),e._v(" abstraction, which is responsible for provisioning, tracking, and authenticating capabilities at runtime. During application initialisation in "),t("code",[e._v("app.go")]),e._v(", the "),t("code",[e._v("CapabilityKeeper")]),e._v(" will\nbe hooked up to modules through unique function references (by calling "),t("code",[e._v("ScopeToModule")]),e._v(", defined below) so that it can identify the calling module when later invoked. When the initial state is loaded from disk, the "),t("code",[e._v("CapabilityKeeper")]),e._v("'s "),t("code",[e._v("Initialise")]),e._v(" function will create new capability keys\nfor all previously allocated capability identifiers (allocated during execution of past transactions and assigned to particular modes), and keep them in a memory-only store while the chain is running. The SDK will include a new "),t("code",[e._v("MemoryStore")]),e._v(" store type, similar\nto the existing "),t("code",[e._v("TransientStore")]),e._v(" but without erasure on "),t("code",[e._v("Commit()")]),e._v(", which this "),t("code",[e._v("CapabilityKeeper")]),e._v(" will use to privately store capability keys.")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("CapabilityKeeper")]),e._v(" will use two stores: a regular, persistent "),t("code",[e._v("KVStore")]),e._v(", which will track what capabilities have been created by each module, and an in-memory "),t("code",[e._v("MemoryStore")]),e._v(" (described below), which will\nstore the actual capabilities. The "),t("code",[e._v("CapabilityKeeper")]),e._v(" will define the following types & functions:")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("Capability")]),e._v(" interface is similar to "),t("code",[e._v("StoreKey")]),e._v(", but has a globally unique "),t("code",[e._v("Index()")]),e._v(" instead of a name. A "),t("code",[e._v("String()")]),e._v(" method is provided for debugging.")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"dHlwZSBDYXBhYmlsaXR5IGludGVyZmFjZSB7CiAgSW5kZXgoKSB1aW50NjQKICBTdHJpbmcoKSBzdHJpbmcKfQo="}}),e._v(" "),t("p",[e._v("A "),t("code",[e._v("CapabilityKey")]),e._v(" is simply a struct, the address of which is taken for the actual capability.")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"dHlwZSBDYXBhYmlsaXR5S2V5IHN0cnVjdCB7CiAgbmFtZSBzdHJpbmcKfQo="}}),e._v(" "),t("p",[e._v("A "),t("code",[e._v("CapabilityKeeper")]),e._v(" contains a persistent store key, memory store key, and mapping of allocated module names.")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"dHlwZSBDYXBhYmlsaXR5S2VlcGVyIHN0cnVjdCB7CiAgcGVyc2lzdGVudEtleSBTdG9yZUtleQogIG1lbW9yeUtleSBNZW1vcnlTdG9yZUtleQogIG1vZHVsZU5hbWVzIG1hcFtzdHJpbmddaW50ZXJmYWNle30KICBzZWFsZWQgYm9vbAp9Cg=="}}),e._v(" "),t("p",[e._v("The "),t("code",[e._v("CapabilityKeeper")]),e._v(" provides the ability to create "),t("em",[e._v("scoped")]),e._v(" sub-keepers which are tied to a particular module name. These "),t("code",[e._v("ScopedCapabilityKeeper")]),e._v("s must be created at application\ninitialisation and passed to modules, which can then use them to claim capabilities they receive and retrieve capabilities which they own by name, in addition\nto creating new capabilities & authenticating capabilities passed by other modules.")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"dHlwZSBTY29wZWRDYXBhYmlsaXR5S2VlcGVyIHN0cnVjdCB7CiAgcGVyc2lzdGVudEtleSBTdG9yZUtleQogIG1lbW9yeUtleSBNZW1vcnlTdG9yZUtleQogIG1vZHVsZU5hbWUgc3RyaW5nCn0K"}}),e._v(" "),t("p",[t("code",[e._v("ScopeToModule")]),e._v(" is used to create a scoped sub-keeper with a particular name, which must be unique. It MUST be called before "),t("code",[e._v("InitialiseAndSeal")]),e._v(".")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyAoY2sgQ2FwYWJpbGl0eUtlZXBlcikgU2NvcGVUb01vZHVsZShtb2R1bGVOYW1lIHN0cmluZykgU2NvcGVkQ2FwYWJpbGl0eUtlZXBlciB7CiAgaWYgY2suc2VhbGVkIHsKICAgIHBhbmljKCZxdW90O2NhcGFiaWxpdHkga2VlcGVyIGlzIHNlYWxlZCZxdW90OykKICB9CiAgaWYgXywgcHJlc2VudCA6PSBjay5tb2R1bGVOYW1lc1ttb2R1bGVOYW1lXTsgcHJlc2VudCB7CiAgICBwYW5pYygmcXVvdDtjYW5ub3QgY3JlYXRlIG11bHRpcGxlIHNjb3BlZCBjYXBhYmlsaXR5IGtlZXBlcnMgZm9yIHRoZSBzYW1lIG1vZHVsZSBuYW1lJnF1b3Q7KQogIH0KICBjay5tb2R1bGVOYW1lc1ttb2R1bGVOYW1lXSA9IHN0cnVjdHt9e30KICByZXR1cm4gU2NvcGVkQ2FwYWJpbGl0eUtlZXBlcnsKICAgIHBlcnNpc3RlbnRLZXk6IGNrLnBlcnNpc3RlbnRLZXksCiAgICBtZW1vcnlLZXk6IGNrLm1lbW9yeUtleSwKICAgIG1vZHVsZU5hbWU6IG1vZHVsZU5hbWUKICB9Cn0K"}}),e._v(" "),t("p",[t("code",[e._v("InitialiseAndSeal")]),e._v(" MUST be called exactly once, after loading the initial state and creating all necessary "),t("code",[e._v("ScopedCapabilityKeeper")]),e._v("s,\nin order to populate the memory store with newly-created capability keys in accordance with the keys previously claimed by particular modules\nand prevent the creation of any new "),t("code",[e._v("ScopedCapabilityKeeper")]),e._v("s.")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyAoY2sgQ2FwYWJpbGl0eUtlZXBlcikgSW5pdGlhbGlzZUFuZFNlYWwoY3R4IENvbnRleHQpIHsKICBpZiBjay5zZWFsZWQgewogICAgcGFuaWMoJnF1b3Q7Y2FwYWJpbGl0eSBrZWVwZXIgaXMgc2VhbGVkJnF1b3Q7KQogIH0KICBwZXJzaXN0ZW50U3RvcmUgOj0gY3R4LktWU3RvcmUoY2sucGVyc2lzdGVudEtleSkKICBtZW1vcnlTdG9yZSA6PSBjdHguS1ZTdG9yZShjay5tZW1vcnlLZXkpCiAgLy8gaW5pdGlhbGlzZSBtZW1vcnkgc3RvcmUgZm9yIGFsbCBuYW1lcyBpbiBwZXJzaXN0ZW50IHN0b3JlCiAgZm9yIGluZGV4LCB2YWx1ZSA6PSByYW5nZSBwZXJzaXN0ZW50U3RvcmUuSXRlcigpIHsKICAgIGNhcGFiaWxpdHkgPSAmYW1wO0NhcGFiaWxpdHlLZXl7aW5kZXg6IGluZGV4fQogICAgZm9yIG1vZHVsZUFuZENhcGFiaWxpdHkgOj0gcmFuZ2UgdmFsdWUgewogICAgICBtb2R1bGVOYW1lLCBjYXBhYmlsaXR5TmFtZSA6PSBtb2R1bGVBbmRDYXBhYmlsaXR5LlNwbGl0KCZxdW90Oy8mcXVvdDspCiAgICAgIG1lbW9yeVN0b3JlLlNldChtb2R1bGVOYW1lICsgJnF1b3Q7L2Z3ZC8mcXVvdDsgKyBjYXBhYmlsaXR5LCBjYXBhYmlsaXR5TmFtZSkKICAgICAgbWVtb3J5U3RvcmUuU2V0KG1vZHVsZU5hbWUgKyAmcXVvdDsvcmV2LyZxdW90OyArIGNhcGFiaWxpdHlOYW1lLCBjYXBhYmlsaXR5KQogICAgfQogIH0KICBjay5zZWFsZWQgPSB0cnVlCn0K"}}),e._v(" "),t("p",[t("code",[e._v("NewCapability")]),e._v(" can be called by any module to create a new unique, unforgeable object-capability\nreference. The newly created capability is automatically persisted; the calling module need not\ncall "),t("code",[e._v("ClaimCapability")]),e._v(".")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyAoc2NrIFNjb3BlZENhcGFiaWxpdHlLZWVwZXIpIE5ld0NhcGFiaWxpdHkoY3R4IENvbnRleHQsIG5hbWUgc3RyaW5nKSAoQ2FwYWJpbGl0eSwgZXJyb3IpIHsKICBtZW1vcnlTdG9yZSA6PSBjdHguS1ZTdG9yZShzY2subWVtb3J5S2V5KQogIC8vIGNoZWNrIG5hbWUgbm90IHRha2VuIGluIG1lbW9yeSBzdG9yZQogIGlmIG1lbW9yeVN0b3JlLkdldCgmcXVvdDtyZXYvJnF1b3Q7ICsgbmFtZSkgIT0gbmlsIHsKICAgIHJldHVybiBuaWwsIGVycm9ycy5OZXcoJnF1b3Q7bmFtZSBhbHJlYWR5IHRha2VuJnF1b3Q7KQogIH0KICAvLyBmZXRjaCB0aGUgY3VycmVudCBpbmRleAogIGluZGV4IDo9IHBlcnNpc3RlbnRTdG9yZS5HZXQoJnF1b3Q7aW5kZXgmcXVvdDspCiAgLy8gY3JlYXRlIGEgbmV3IGNhcGFiaWxpdHkKICBjYXBhYmlsaXR5IDo9ICZhbXA7Q2FwYWJpbGl0eUtleXtpbmRleDogaW5kZXh9CiAgLy8gc2V0IHBlcnNpc3RlbnQgc3RvcmUKICBwZXJzaXN0ZW50U3RvcmUuU2V0KGluZGV4LCBTZXQuc2luZ2xldG9uKHNjay5tb2R1bGVOYW1lICsgJnF1b3Q7LyZxdW90OyArIG5hbWUpKQogIC8vIHVwZGF0ZSB0aGUgaW5kZXgKICBpbmRleCsrCiAgcGVyc2lzdGVudFN0b3JlLlNldCgmcXVvdDtpbmRleCZxdW90OywgaW5kZXgpCiAgLy8gc2V0IGZvcndhcmQgbWFwcGluZyBpbiBtZW1vcnkgc3RvcmUgZnJvbSBjYXBhYmlsaXR5IHRvIG5hbWUKICBtZW1vcnlTdG9yZS5TZXQoc2NrLm1vZHVsZU5hbWUgKyAmcXVvdDsvZndkLyZxdW90OyArIGNhcGFiaWxpdHksIG5hbWUpCiAgLy8gc2V0IHJldmVyc2UgbWFwcGluZyBpbiBtZW1vcnkgc3RvcmUgZnJvbSBuYW1lIHRvIGNhcGFiaWxpdHkKICBtZW1vcnlTdG9yZS5TZXQoc2NrLm1vZHVsZU5hbWUgKyAmcXVvdDsvcmV2LyZxdW90OyArIG5hbWUsIGNhcGFiaWxpdHkpCiAgLy8gcmV0dXJuIHRoZSBuZXdseSBjcmVhdGVkIGNhcGFiaWxpdHkKICByZXR1cm4gY2FwYWJpbGl0eQp9Cg=="}}),e._v(" "),t("p",[t("code",[e._v("AuthenticateCapability")]),e._v(" can be called by any module to check that a capability\ndoes in fact correspond to a particular name (the name can be untrusted user input)\nwith which the calling module previously associated it.")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyAoc2NrIFNjb3BlZENhcGFiaWxpdHlLZWVwZXIpIEF1dGhlbnRpY2F0ZUNhcGFiaWxpdHkobmFtZSBzdHJpbmcsIGNhcGFiaWxpdHkgQ2FwYWJpbGl0eSkgYm9vbCB7CiAgbWVtb3J5U3RvcmUgOj0gY3R4LktWU3RvcmUoc2NrLm1lbW9yeUtleSkKICAvLyByZXR1cm4gd2hldGhlciBmb3J3YXJkIG1hcHBpbmcgaW4gbWVtb3J5IHN0b3JlIG1hdGNoZXMgbmFtZQogIHJldHVybiBtZW1vcnlTdG9yZS5HZXQoc2NrLm1vZHVsZU5hbWUgKyAmcXVvdDsvZndkLyZxdW90OyArIGNhcGFiaWxpdHkpID09PSBuYW1lCn0K"}}),e._v(" "),t("p",[t("code",[e._v("ClaimCapability")]),e._v(" allows a module to claim a capability key which it has received from another module so that future "),t("code",[e._v("GetCapability")]),e._v(" calls will succeed.")]),e._v(" "),t("p",[t("code",[e._v("ClaimCapability")]),e._v(" MUST be called if a module which receives a capability wishes to access it by name in the future. Capabilities are multi-owner, so if multiple modules have a single "),t("code",[e._v("Capability")]),e._v(" reference, they will all own it.")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyAoc2NrIFNjb3BlZENhcGFiaWxpdHlLZWVwZXIpIENsYWltQ2FwYWJpbGl0eShjdHggQ29udGV4dCwgY2FwYWJpbGl0eSBDYXBhYmlsaXR5LCBuYW1lIHN0cmluZykgZXJyb3IgewogIHBlcnNpc3RlbnRTdG9yZSA6PSBjdHguS1ZTdG9yZShzY2sucGVyc2lzdGVudEtleSkKICBtZW1vcnlTdG9yZSA6PSBjdHguS1ZTdG9yZShzY2subWVtb3J5S2V5KQogIC8vIHNldCBmb3J3YXJkIG1hcHBpbmcgaW4gbWVtb3J5IHN0b3JlIGZyb20gY2FwYWJpbGl0eSB0byBuYW1lCiAgbWVtb3J5U3RvcmUuU2V0KHNjay5tb2R1bGVOYW1lICsgJnF1b3Q7L2Z3ZC8mcXVvdDsgKyBjYXBhYmlsaXR5LCBuYW1lKQogIC8vIHNldCByZXZlcnNlIG1hcHBpbmcgaW4gbWVtb3J5IHN0b3JlIGZyb20gbmFtZSB0byBjYXBhYmlsaXR5CiAgbWVtb3J5U3RvcmUuU2V0KHNjay5tb2R1bGVOYW1lICsgJnF1b3Q7L3Jldi8mcXVvdDsgKyBuYW1lLCBjYXBhYmlsaXR5KQogIC8vIHVwZGF0ZSBvd25lciBzZXQgaW4gcGVyc2lzdGVudCBzdG9yZQogIG93bmVycyA6PSBwZXJzaXN0ZW50U3RvcmUuR2V0KGNhcGFiaWxpdHkuSW5kZXgoKSkKICBvd25lcnMuYWRkKHNjay5tb2R1bGVOYW1lICsgJnF1b3Q7LyZxdW90OyArIG5hbWUpCiAgcGVyc2lzdGVudFN0b3JlLlNldChjYXBhYmlsaXR5LkluZGV4KCksIG93bmVycykKfQo="}}),e._v(" "),t("p",[t("code",[e._v("GetCapability")]),e._v(" allows a module to fetch a capability which it has previously claimed by name. The module is not allowed to retrieve capabilities which it does not own. If another module\nclaims a capability, the previously owning module will no longer be able to claim it.")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyAoc2NrIFNjb3BlZENhcGFiaWxpdHlLZWVwZXIpIEdldENhcGFiaWxpdHkoY3R4IENvbnRleHQsIG5hbWUgc3RyaW5nKSAoQ2FwYWJpbGl0eSwgZXJyb3IpIHsKICBtZW1vcnlTdG9yZSA6PSBjdHguS1ZTdG9yZShzY2subWVtb3J5S2V5KQogIC8vIGZldGNoIGNhcGFiaWxpdHkgZnJvbSBtZW1vcnkgc3RvcmUKICBjYXBhYmlsaXR5IDo9IG1lbW9yeVN0b3JlLkdldChzY2subW9kdWxlTmFtZSArICZxdW90Oy9yZXYvJnF1b3Q7ICsgbmFtZSkKICAvLyByZXR1cm4gdGhlIGNhcGFiaWxpdHkKICByZXR1cm4gY2FwYWJpbGl0eQp9Cg=="}}),e._v(" "),t("h3",{attrs:{id:"memory-store"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#memory-store"}},[e._v("#")]),e._v(" Memory store")]),e._v(" "),t("p",[e._v("A new store key type, "),t("code",[e._v("MemoryStoreKey")]),e._v(", will be added to the "),t("code",[e._v("store")]),e._v(" package. The "),t("code",[e._v("MemoryStoreKey")]),e._v("s work just like "),t("code",[e._v("StoreKey")]),e._v("s.")]),e._v(" "),t("p",[e._v("The memory store will work just like the current transient store, except that it will not create a new "),t("code",[e._v("dbadapter.Store")]),e._v(" when "),t("code",[e._v("Commit()")]),e._v(" is called, but instead retain the current one (so that state will persist across blocks).")]),e._v(" "),t("p",[e._v("Initially the memory store will only be used by the "),t("code",[e._v("CapabilityKeeper")]),e._v(", but it could be used by other modules in the future.")]),e._v(" "),t("h3",{attrs:{id:"usage-patterns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#usage-patterns"}},[e._v("#")]),e._v(" Usage patterns")]),e._v(" "),t("h4",{attrs:{id:"initialisation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#initialisation"}},[e._v("#")]),e._v(" Initialisation")]),e._v(" "),t("p",[e._v("Any modules which use dynamic capabilities must be provided a "),t("code",[e._v("ScopedCapabilityKeeper")]),e._v(" in "),t("code",[e._v("app.go")]),e._v(":")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"Y2sgOj0gTmV3Q2FwYWJpbGl0eUtlZXBlcihwZXJzaXN0ZW50S2V5LCBtZW1vcnlLZXkpCm1vZDFLZWVwZXIgOj0gTmV3TW9kMUtlZXBlcihjay5TY29wZVRvTW9kdWxlKCZxdW90O21vZDEmcXVvdDspLCAuLi4uKQptb2QyS2VlcGVyIDo9IE5ld01vZDJLZWVwZXIoY2suU2NvcGVUb01vZHVsZSgmcXVvdDttb2QyJnF1b3Q7KSwgLi4uLikKCi8vIG90aGVyIGluaXRpYWxpc2F0aW9uIGxvZ2ljIC4uLgoKLy8gbG9hZCBpbml0aWFsIHN0YXRlLi4uCgpjay5Jbml0aWFsaXNlQW5kU2VhbChpbml0aWFsQ29udGV4dCkK"}}),e._v(" "),t("h4",{attrs:{id:"creating-passing-claiming-and-using-capabilities"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#creating-passing-claiming-and-using-capabilities"}},[e._v("#")]),e._v(" Creating, passing, claiming and using capabilities")]),e._v(" "),t("p",[e._v("Consider the case where "),t("code",[e._v("mod1")]),e._v(" wants to create a capability, associate it with a resource (e.g. an IBC channel) by name, then pass it to "),t("code",[e._v("mod2")]),e._v(" which will use it later:")]),e._v(" "),t("p",[e._v("Module 1 would have the following code:")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"Y2FwYWJpbGl0eSA6PSBzY29wZWRDYXBhYmlsaXR5S2VlcGVyLk5ld0NhcGFiaWxpdHkoY3R4LCAmcXVvdDtyZXNvdXJjZUFCQyZxdW90OykKbW9kMktlZXBlci5Tb21lRnVuY3Rpb24oY3R4LCBjYXBhYmlsaXR5LCBhcmdzLi4uKQo="}}),e._v(" "),t("p",[t("code",[e._v("SomeFunction")]),e._v(", running in module 2, could then claim the capability:")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyAoayBNb2QyS2VlcGVyKSBTb21lRnVuY3Rpb24oY3R4IENvbnRleHQsIGNhcGFiaWxpdHkgQ2FwYWJpbGl0eSkgewogIGsuc2NrLkNsYWltQ2FwYWJpbGl0eShjdHgsIGNhcGFiaWxpdHksICZxdW90O3Jlc291cmNlQUJDJnF1b3Q7KQogIC8vIG90aGVyIGxvZ2ljLi4uCn0K"}}),e._v(" "),t("p",[e._v("Later on, module 2 can retrieve that capability by name and pass it to module 1, which will authenticate it against the resource:")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyAoayBNb2QyS2VlcGVyKSBTb21lT3RoZXJGdW5jdGlvbihjdHggQ29udGV4dCwgbmFtZSBzdHJpbmcpIHsKICBjYXBhYmlsaXR5IDo9IGsuc2NrLkdldENhcGFiaWxpdHkoY3R4LCBuYW1lKQogIG1vZDEuVXNlUmVzb3VyY2UoY3R4LCBjYXBhYmlsaXR5LCAmcXVvdDtyZXNvdXJjZUFCQyZxdW90OykKfQo="}}),e._v(" "),t("p",[e._v("Module 1 will then check that this capability key is authenticated to use the resource before allowing module 2 to use it:")]),e._v(" "),t("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyAoayBNb2QxS2VlcGVyKSBVc2VSZXNvdXJjZShjdHggQ29udGV4dCwgY2FwYWJpbGl0eSBDYXBhYmlsaXR5LCByZXNvdXJjZSBzdHJpbmcpIHsKICBpZiAhay5zY2suQXV0aGVudGljYXRlQ2FwYWJpbGl0eShuYW1lLCBjYXBhYmlsaXR5KSB7CiAgICByZXR1cm4gZXJyb3JzLk5ldygmcXVvdDt1bmF1dGhlbnRpY2F0ZWQmcXVvdDspCiAgfQogIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXNvdXJjZQp9Cg=="}}),e._v(" "),t("p",[e._v("If module 2 passed the capability key to module 3, module 3 could then claim it and call module 1 just like module 2 did\n(in which case module 1, module 2, and module 3 would all be able to use this capability).")]),e._v(" "),t("h2",{attrs:{id:"status"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#status"}},[e._v("#")]),e._v(" Status")]),e._v(" "),t("p",[e._v("Proposed.")]),e._v(" "),t("h2",{attrs:{id:"consequences"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#consequences"}},[e._v("#")]),e._v(" Consequences")]),e._v(" "),t("h3",{attrs:{id:"positive"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#positive"}},[e._v("#")]),e._v(" Positive")]),e._v(" "),t("ul",[t("li",[e._v("Dynamic capability support.")])]),e._v(" "),t("h3",{attrs:{id:"negative"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#negative"}},[e._v("#")]),e._v(" Negative")]),e._v(" "),t("ul",[t("li",[e._v("Requires an additional keeper.")]),e._v(" "),t("li",[e._v("Some overlap with existing "),t("code",[e._v("StoreKey")]),e._v(" system (in the future they could be combined, since this is a superset functionality-wise).")])]),e._v(" "),t("h3",{attrs:{id:"neutral"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#neutral"}},[e._v("#")]),e._v(" Neutral")]),e._v(" "),t("p",[e._v("(none known)")]),e._v(" "),t("h2",{attrs:{id:"references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/pull/5230#discussion_r343978513",target:"_blank",rel:"noopener noreferrer"}},[e._v("Original discussion"),t("OutboundLink")],1)])])],1)}),[],!1,null,null,null);a.default=i.exports}}]);